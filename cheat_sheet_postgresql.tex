\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Наиболее полезные конструкции PostgreSQL}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Логический порядок обработки инструкции \texttt{SELECT}}

Порядок обработки инструкции \texttt{SELECT} определяет, когда объекты, определенные в одном шаге, становятся доступными для предложений в последующих шагах. Например, если обработчик запросов можно привязать к таблицам или представлениям, определенным в предложении \texttt{FROM}, эти объекты и их столбцы становятся доступными для всех последующих шагов.

Общая процедура выполнения \texttt{SELECT} следущая (подробности см. в документации~\href{https://postgrespro.ru/docs/postgresql/9.5/sql-select}{\texttt{SELECT}}):

\begin{enumerate}
	\item \texttt{WITH}: выполняются все запросы в списке \texttt{WITH}; по сути они формируют временные таблицы, к которым затем можно обращаться в списке \texttt{FROM}; запрос в \texttt{WITH} выполняется только один раз, даже если он фигурирует в списке \texttt{FROM} неоднократно,
	
	\item \texttt{FROM}: вычисляются все элементы в списке \texttt{FROM} (каждый элемент в списке \texttt{FROM} представляет собой реальную или виртуальную таблицу); другими словами конструируются таблицы из списка \texttt{FROM},
	
	\item \texttt{ON}: выбираются строки, удовлетворяющие заданному условию,
	
	\item \texttt{JOIN}: выполняется объединение таблиц,
	
	\item \texttt{WHERE}: исключаются строки, не удовлетворяющие заданному условию,
	
	\item \texttt{GROUP BY}: вывод разделяется по группам строк, соответствующим одному или нескольким значениям, а затем вычисляются результаты агрегатных функций,
	
	\item \texttt{HAVING}: исключаются группы, не удовлетворяющие заданному условию,
	
	\item \texttt{SELECT},
	
	\item \texttt{DISTINCT}: исключаются \emph{повторяющиеся} строки; \texttt{SELECT DISTINCT ON} исключает строки, совпадающие по всем указанным выражениям; \texttt{SELECT ALL} (по умолчанию) возвращает все строки результата, включая дубликаты,
	
	\item \texttt{UNION}, \texttt{INTERSECT} и \texttt{EXCEPT}: объединяется вывод нескольких команд \texttt{SELECT} в один результирующий набор.
	
	\item \texttt{ORDER BY}: строки сортируются в указанном порядке; в отсутствие \texttt{ORDER BY} строки возвращаются в том порядке, в каком системе будет проще их выдавать,
	
	\item \texttt{LIMIT} (или \texttt{FETCH FIRST}), либо \texttt{OFFSET}: возвращается только подмножество строк результата.
	
	\item Если указано \texttt{FOR UPDATE}, \texttt{FOR NO KEY UPDATE}, \texttt{FOR SHARE} или \texttt{FOR KEY SHARE}, оператор \texttt{SELECT} блокирует выбранные строки, защищая их от одновременных изменений.
\end{enumerate}

\section{Смена схемы базы данных}

Вывести список доступных схем

\begin{lstlisting}[
style = sql,
numbers = none,
]
SHOW search_path;
\end{lstlisting}

Задать схему 

\begin{lstlisting}[
style = sql,
numbers = none
]
SET search_path TO new_schema;
\end{lstlisting}
или, если требуется доступ к нескольким схемам
\begin{lstlisting}[
style = sql,
numbers = none,
]
SET search_path TO new_schema1, new_schema2, public;
\end{lstlisting}

\section{Обновление записей}

Изменить слово Drama на Dramatic в столбце \texttt{kind} таблицы \texttt{films}

\begin{lstlisting}[
style = sql,
numbers = none,
]
UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';
\end{lstlisting}

Изменить значение температуры и сбросить уровень осадков к значению по умолчанию в одной строке таблицы \texttt{weather}

\begin{lstlisting}[
style = sql,
numbers = none,
deletekeywords = {date}
]
UPDATE
    weather
SET
    temp_lo = temp_lo + 1,
    temp_hi = temp_lo + 15,
    prcp = DEFAULT
WHERE
    city = 'San Francisco' AND
    dates = '2003-07-03';
\end{lstlisting}


\section{Общие табличные выражения}

В конструкциях общих табличных выражений с \texttt{WITH} имена временных таблиц указываются \emph{без} перечисления имен столбцов, а в конструкциях с \texttt{WITH RECURSIVE} -- с перечислением, например, \lstinline[style=sql]{WITH RECURSIVE tab(col1, col2, ...) AS (...)}.

\subsection{Оператор \texttt{WITH}}

Основное предназначение \texttt{SELECT} в предложении \texttt{WITH} (Common Table Expression, Общие Табличные Выражения) заключается в разбиении сложных запросов на простые части. Например, пусть задана некоторая таблица \texttt{orders}\footnote{См.~документацию \psql~ \url{https://postgrespro.ru/docs/postgrespro/9.5/queries-with}}

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH --part 1, common table expression
    regional_sales AS ( --def temp_table1
        SELECT region, sum(amount) AS total_sales
        FROM orders --base table
        GROUP BY region
    ),
    top_regions AS ( --def temp_table2
        SELECT region
        FROM regional_sales --temp_table1
        WHERE total_sales > (
                    SELECT SUM(total_sales)/10
                    FROM regional_sales --temp_table2
        )
    )
SELECT --part 2
    region,
    product,
    SUM(quantity) AS product_units,
    SUM(amount) AS product_sales
FROM orders
WHERE region IN (
            SELECT region
            FROM top_regions --temp_table2
)
GROUP BY region, product;
\end{lstlisting}

Здесь в инструкции \texttt{WITH} объявляются две \emph{временные таблицы} \texttt{regional\_sales} и \texttt{top\_regions}. Вторая временная таблица \texttt{top\_regions} ссылается на временную таблицу \texttt{regional\_sales}, сформированную в первых строках настоящего запроса. Во второй части запроса также используется временная таблица \texttt{top\_regions}.

Еще один пример. Пусть задана таблица
\begin{lstlisting}[
style = sql,
numbers = none,
]
# SELECT * FROM test_tab;
 id |    cae_name     |  solver  | num_cores
  1 | ANSYS           | Direct   |        32
  3 | Comsole         | Direct   |        16
  4 | LMS Virtual Lab | Direct   |        32
  2 | Nastran         | Iterativ |        16
(4 строки)
\end{lstlisting}

Требуется выяснить сколько CAE-пакетов имеют прямой, а сколько итерационный решатель. Эту задачу можно решить следующим образом

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH sub_tab AS ( --make temp table
    SELECT solver, 1 AS count
    FROM test_tab
)
SELECT solver, sum(count)
FROM sub_tab --link to temp table
GROUP BY solver;
\end{lstlisting}

Часть с \texttt{WITH} возвращает

\begin{lstlisting}[
style = sql,
numbers = none,
]
# SELECT solver, 1 AS count FROM test_tab;
 solver   | count
=================
 Direct   |     1
 Direct   |     1
 Direct   |     1
 Iterativ |     1
(4 строки)
\end{lstlisting}

Полезный пример с использованием конструкции \lstinline{CASE...END} и \lstinline{WHEN...THEN}

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH cte_film AS ( --part 1
    SELECT
        film_id,
        title,
        (CASE --start block
            WHEN length < 30 THEN 'Short'
            WHEN length < 90 THEN 'Medium'
            ELSE 'Long'
         END) length
    FROM
        film
)
SELECT --part 2
    film_id,
    title,
    length
FROM
    cte_film
WHERE
    length = 'Long'
ORDER BY
    title;
\end{lstlisting}

Пример с использованием логических операторов

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH cte_films AS (
    SELECT
        film_id,
        title,
        (CASE
            WHEN length < 30 THEN 'Short'
            WHEN length >= 30 AND length < 90 THEN 'Medium'
            WHEN length > 90 THEN 'Long'
        END) length
    FROM
        film
)

\end{lstlisting}

\subsection{Оператор \texttt{WITH RECURSIVE}}

Если к \texttt{WITH} добавить \texttt{RECURSIVE}, то можно будет получить доступ к промежуточному результату. Например,

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE tbl(n) AS ( --part 1
    SELECT 1 --or VALUES(1). This is nonrecursive part
    UNION ALL
    SELECT n+1 FROM tbl WHERE n < 10  --and this is recursive part
)
SELECT sum(n) from tbl; --part 2
\end{lstlisting}

На первой итерации в таблице \texttt{tbl} в атрибуте \texttt{n} находится значение 1. На этом вычисления некурсивной части заканчиваются. Далее переходим к вычислениям в рекурсивной части. Таблица \texttt{tbl} ссылается на последнее вычисленное значение, поэтому на второй итерации удается выполнить \texttt{n+1}, после чего новым значением таблицы \texttt{tbl} станет 2 (\lstinline{tbl -> 2}). Проверяем условие \lstinline{n < 10}, а затем переходим к следующей итерации и т.д.

Удобно представлять, что вычисленные значения хранятся в некоторой промежуточной области в порядке вычисления, а таблица \texttt{tbl} всегда ссылается на последнее вычисленное значение.

На последнем этапе \texttt{1} объединяется с \texttt{2}, \texttt{3} и т.д., т.е. в итоге получается последовательность от 1 до 10. Во второй части запроса остается лишь просуммировать элементы этой последовательности и вывести на экран.

Рассмотрим еще такой пример

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE
    included_parts(sub_part, part, quantity) AS (
        SELECT --nonrecursive part
            sub_part,
            part,
            quantity
        FROM parts --base table
        WHERE part = "our_product"
            UNION ALL
        SELECT --recursive part
            p.sub_part,
            p.part,
            p.quantity
        FROM
            included_parts pr,
            parts p
        WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) AS total_quantity
FROM included_parts
GROUP BY sub_part
\end{lstlisting}

На первой итерации временная таблица \texttt{included\_parts}, вычисленная в некурсивной части, представляет собой результат выборки строк и столбцов из таблицы \texttt{parts}. В рекурсивной части можно получить доступ к этой таблице. В завершении выполняем выборку из таблицы \texttt{included\_parts} по столбцу \texttt{sub\_part}, группируем по нему и выводим сумму по \texttt{quantity}.

Еще один полезный пример. Пусть дана таблица сотрудников

\begin{lstlisting}[
title = {\sffamily employees},
numbers = none]
id | name   | salary | job              | manager_id
====================================================
1  | John   | 10000  | CEO              | null
2  | Ben    | 1400   | Junior Developer | 5
3  | Barry  | 500    | Intern           | 5
4  | George | 1800   | Developer        | 5
5  | James  | 3000   | Manager          | 7
6  | Steven | 2400   | DevOps Engineer  | 7
7  | Alice  | 4200   | VP               | 1
8  | Jerry  | 3500   | Manager          | 1
9  | Adam   | 2000   | Data Analyst     | 8
10 | Grace  | 2500   | Developer        | 8
11 | Leor   | 5000   | Data Scientist   | 6
\end{lstlisting}

Выведем иерархию подчинения сотрудников в компании

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE managers(id, name, manager_id, job, level) AS (
    SELECT id, name, manager_id, job, 1
    FROM employees --base table
    WHERE id = 7
        UNION ALL
    SELECT e.id, e.name, e.manager_id, e.job, m.level+1
    FROM employees e JOIN managers m ON e.manager_id = m.id
)
SELECT * FROM managers;
\end{lstlisting}

Сначала в \emph{некурсивной} части \texttt{WITH RECURSIVE} объявляется временная таблица \texttt{managers(id, name, ...)}. Она строится на базе таблицы \texttt{employees}, к которой слева добавляется столбец, состоящий из одних единиц. Затем выбираются строки, удовлетворяющие условию \texttt{WHERE}; в данном случае это одна строка \texttt{e.manager\_id=m.id}.

И, таким образом, на данном этапе во \emph{временную} таблицу \texttt{managers} попадет только одна строка
\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в нерекурсивной части},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
7  | Alice  | 1          | VP               | 1
\end{lstlisting}

Переходим в рекурсивную часть CTE. Из базовой таблицы \texttt{employees} выбираем те строки, которые в столбце \texttt{manager\_id} имеют те же значения, что и в столбце \texttt{id} временной таблицы \texttt{managers} (на данном этапе таблица состоит из одной строки). Другими словами, выбрать нужно те строки, у которых в столбце \texttt{manager\_id} таблицы \texttt{employees} стоит цифра 7.

В результате временная таблица \texttt{managers} на текущем этапе будет иметь вид

\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в рекурсивной части},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
5  | James  | 7          | Manager          | 2
6  | Steven | 7          | DevOps Engineer  | 2
\end{lstlisting}

Временные таблицы \emph{рекурсивных общих табличных выражений} всегда ссылаются на результат последних вычислений, т.е. на данном этапе временная таблица \texttt{managers} ссылается на таблицу, состоящую из двух строк.

Теперь мы снова выбираем из базовой таблицы \texttt{employees} и временной таблицы те строки, у которых в столбцах \texttt{e.manager\_id} и \texttt{m.id} стоят одинаковые числа (в данном случае 5 и 6).

Таким образом

\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в рекурсивной части на 2-ой итерации},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
2  | Ben    | 5          | Junior Developer | 3
3  | Barry  | 5          | Intern           | 3
4  | George | 5          | Developer        | 3 
11 | Leor   | 6          | Data Scientist   | 3 
\end{lstlisting}


Наконец все временные подтаблицы <<склеиваются>> и конструкция \lstinline[style = sql]{SELECT * FROM managers} возвращает таблицу \texttt{managers}

\begin{lstlisting}[
style = sql,
numbers = none
]
id | name   | manager_id | job              | level
========================================================
7  | Alice  | 1          | VP               | 1 --step 1
--------------------------------------------------------
5  | James  | 7          | Manager          | 2 --step 2
6  | Steven | 7          | DevOps Engineer  | 2 --step 2
--------------------------------------------------------
2  | Ben    | 5          | Junior Developer | 3 --step 3
3  | Barry  | 5          | Intern           | 3 --step 3
4  | George | 5          | Developer        | 3 --step 3
11 | Leor   | 6          | Data Scientist   | 3 --step 3
\end{lstlisting}





\subsection{Изменение данных в \texttt{WITH}}

В предложении \texttt{WITH} можно также использовать операторы, изменяющие данные (\texttt{INSERT}, \texttt{UPDATE} или \texttt{DELETE}). Это позволяет выполнять в одном запросе сразу несколько разных операций. Например

\begin{lstlisting}[
style = sql,
numbers = none
]
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        dates >= '2010-10-01' AND
        dates < '2010-11-01'
    RETURNING *
)
INSERT INTO products_log (SELECT * FROM moved_rows);
\end{lstlisting}

Этот запрос фактически перемещает строки из таблицы \texttt{products} в таблицу \texttt{products\_log} (таблица должна уже существовать на момент выполнения запроса). Оператор \texttt{DELETE} удаляет указанные строки из \texttt{products} и возвращает их содержимое в предложении \texttt{RETURNING}, а затем главный запрос читает это содержимое и вставляет в таблицу \texttt{products\_log}.

\section{Работа со строками и регулярные выражения}

Больше информации про строковые функции и операторы можно найти на страницах официальной документации \texttt{PostgreSQL} по ссылке \url{https://postgrespro.ru/docs/postgrespro/9.6/functions-string}.

Пусть дана таблица \texttt{employees} вида
\begin{lstlisting}[
numbers = none
]
 id |  name  | salary |       job        | manager_id
----+--------+--------+------------------+------------
  1 | John   |  10000 | CEO              |
  2 | Ben    |   1400 | Junior Developer |          5
  3 | Barry  |    500 | Intern           |          5
  4 | George |   1800 | Developer        |          5
  5 | James  |   3000 | Manager          |          7
  6 | Steven |   2400 | DevOps Engineer  |          7
  7 | Alice  |   4200 | VP               |          1
  8 | Jerry  |   3500 | Manager          |          1
  9 | Adam   |   2000 | Data Analyst     |          8
 10 | Grace  |   2500 | Developer        |          8
 11 | Leor   |  50000 | Data Scientist   |          6
\end{lstlisting}

Выбрать те строки из столбца \texttt{job}, в которых содержатся строковые значения, удовлетворяющие шаблону \texttt{'\_ata \%'}, означающий, что первый символ строки может быть любым, а после пробелов может не быть ни одного символа или быть сколько угодно символов. То есть символ <<\texttt{\_}>> совпадает с любым символом, а символ <<\texttt{\%}>> совпадает с произвольным количеством символов. Здесь используется предложение \texttt{LIKE}, которое чувствительно к регистру. В качестве альтернативного варианта можно использовать предложение \texttt{ILIKE}\footnote{Это расширение \texttt{PostgreSQL}, которое не имеет отношения к стандарту \texttt{SQL}}, которое не учитывает регистр.

\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job LIKE '_ata %';
\end{lstlisting}

Выведет
\begin{lstlisting}[
numbers = none
]
 id | name | salary |      job       | manager_id
----+------+--------+----------------+------------
  9 | Adam |   2000 | Data Analyst   |          8
 11 | Leor |  50000 | Data Scientist |          6
\end{lstlisting}

Подобные задачи можно решать и с помощью предложения \texttt{SIMILAR TO}, которое похоже на \texttt{LIKE}, но в отличие от последнего при интерпретации шаблонов использует определение регулярного выражения стандарта \texttt{SQL}. Регулярные выражения \texttt{SQL} -- это смесь нотации предложения \texttt{LIKE} и нотации регулярных выражений.

Шаблоны и \texttt{LIKE}, и \texttt{SIMILAR TO} должны соответствовать \emph{всей} строке целиком, что, вообще говоря, не согласуется с концепцией обычных регулярных выражений, когда шаблон может соответствовать любой части строки. 

\texttt{SIMILAR TO}, как и \texttt{LIKE} использует символ <<\texttt{\_}>> и символ <<\texttt{\%}>>, что соотвествует \texttt{.} и \texttt{.*} в регулярных выражениях \texttt{POSIX}. Дополнительно поддерживаются символы \texttt{|} (указывает альтернативные варианты), \texttt{*} (указывает, что стоящий слева элемент повторяется ноль или более раз), \texttt{+} (указывает, что стоящий слева элемент повторяется один или более раз), \texttt{(...)} (могут использоваться для указания групп), а \texttt{[...]} (определяют символьный класс как в \texttt{POSIX}). Однако \texttt{?} и \texttt{\{...\}} не поддерживаются и кроме того <<\texttt{.}>> не является метасимволом.

Символ <<\verb|\|>> экранирует метасимволы, т.е. <<снимает>> их специальное значение. Другой символ для экранирования можно задать с помощью предложения \texttt{ESCAPE}.

Рассмотренную выше задачу можно решить с помощью \texttt{SIMILAR TO} следующим образом
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job SIMILAR TO '_ata (A|S)%';
\end{lstlisting}

Здесь символ <<\texttt{\%}>>, означающий произвольную последовательность символов, обязателен, так как шаблоны \texttt{SIMILAR TO} должны совпадать со \emph{всей строкой}.

Очень полезна бывает функция \texttt{substring()}. Как и \texttt{SIMILAR TO} шаблон должен совпадать со всей строкой, например
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job FROM employees
WHERE substring(job from '%#"Dev#"%' for '#')='Dev';
\end{lstlisting}

Последовательность символов \texttt{\#"...\#"} задают левую и правую скобки группы (можно указать и какой-то другой символ в качестве скобки, например, \texttt{:"...:"}, но его нужно указать в \texttt{... for ':'}). Последовательность, попавшая между этих символов будет возвращена. Как и раньше символы <<\texttt{\%}>> здесь нужны для того чтобы шаблон совпадал со всей строкой.

Обрезать строку можно так
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job, substring(job,1,4) FROM employees;
\end{lstlisting}

Здесь первое число -- позиция элемента строки (нумерация начинается с единицы), а второе число -- число элементов подстроки, которое нужно оставить в выводе.

Эквивалентная конструкция
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job, substring(job from 1 for 4) FROM employees;
\end{lstlisting}

Очень гибкое решение дают \emph{регулярные выражения} \texttt{POSIX} (Portable Operating System Interface -- переносимый интерфейс операционных систем). Например для того чтобы выбрать, как и в рассмотренном выше примере, всех, кто имеет отношение к работе с данными, можно использовать такую конструкцию
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job ~* 'data .*';
\end{lstlisting}

Здесь \verb|~*| -- оператор соответствию шаблону \emph{без} учета регистра. Если нужно учесть регистр, то используется оператор \verb|~|.

Аналогично \verb|!~| -- оператор несоответствия шаблону с учетом регистра, оператор \verb|!~*| -- оператор несоответствия шаблону \emph{без} учета регистра.

Регулярные выражения могут совпадать с строкой в любом месте (не обязательно со всей строкой).

Еще пример. Нужно выбрать строки из столбца \texttt{job}, в которых последовательность символов \texttt{dev} стоит в начале строки (<<\verb|^|>> -- якорь начала строки)

\begin{lstlisting}[
style = sql,
numbers = none
]
select * from employees where job ~* '^dev.*';
\end{lstlisting}

Пример с положительной проверкой вперед
\begin{lstlisting}[
style = sql,
numbers = none
]
select * from employees where job ~* '(?=engineer)';
\end{lstlisting}

Выведет
\begin{lstlisting}[
numbers = none
]
 id |  name  | salary |       job       | manager_id
----+--------+--------+-----------------+------------
  6 | Steven |   2400 | DevOps Engineer |          7
 20 | Alex   |  25050 | Data Engineer   |         10
\end{lstlisting}

У регулярных выражений есть один тонкий нюанс, связанный с <<жадностью>> квантификатора. Рассмотрим пример
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT substring('xy1234z', 'y*(\d{1,3})');  -- вернет '123'
\end{lstlisting}

Здесь используется <<жадный>> квантификатор \texttt{*}. В общем случае этот квантификатор соответствует элементу, который не повторяется ни разу или повторяется произвольное число раз, однако в данном случае он соответствует строго единственному символу \texttt{'y'} (больше в строке символов \texttt{'y'} нет). Другими словами подшаблон \texttt{y*} жадно забирает символ \texttt{'y'} и на этом успокаивается, так как больше ничего от этой последовательности взять не сможет. А затем подшаблон \verb|\d{1,3}| жадно забирает 3 цифры, так как ему никто не мешает это сделать.

Но если использовать <<нежадный>> вариант квантификатора \texttt{*?}, то картина изменится
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT substring('xy1234z', 'y*?(\d{1,3})');  -- вернет '1'
\end{lstlisting}

Вариант, когда подстрока не имеет ни одного элемента устраивает подшаблон \texttt{y*?} (потому что используется нежадный квантификатор), но не устраивает подшаблон \verb|\d{1,3}|, согласно которому в последовательности должна быть хотя бы одна цифра. Приходится как бы <<тянуть>> подшаблон \texttt{y*?} вправо, потому что нежадный квантификатор стремится схлопнуться в пустое начало строки. Таким образом, на 2-ой итерации курсор сдвигается вправо на один символ и теперь указывате на \texttt{'x'}. Нежадный подшаблон \texttt{y*?} удовлетворен (ему достаточно и пустой подстроки), но не удовлетворен второй подшаблон. Курсор передвигается еще на один элемент вправо. И теперь указывает на \texttt{'y'} (подстрока: \texttt{'xy'}). Нежадный подшаблон \texttt{y*?} снова удовлетворен, но подшаблон \verb|\d{1,3}| все еще не содержит ни одной цифры, поэтому курсор снова перемещается вправо еще на один элемент. В этот раз подстрока выглядит как \texttt{'xy1'}, что удовлетворяет и первый, и второй подшаблоны, но подшаблон \texttt{y*?} больше бы устроил вариант, когда подстрока пустая. С другой стороны подшаблон \verb|\d{1,3}| требует, чтобы в подстроке была хотя бы одна цифра, поэтому подстрока вида \texttt{'xy1'} (в группу попадает только \texttt{1}) -- это компромисс.

\remark{
Удобно представлять, что \emph{нежадные квантификаторы} типа \texttt{*?} представляют собой пружинки сжатия, которые тянут влево и в самом простом случае довольствуются пустой последовательностью, а \emph{жадные квантификаторы} (\texttt{*}) можно представлять как пружинки растяжения, которые стремятся занять всю последовательность и с неохотой уступают элементы
}


\section{Приемы работы в \texttt{pgAdmin 4}}

\section{Приемы работы в \texttt{psql}}


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{chacon:2020}{ \emph{Чакон С.}, \emph{Штрауб Б.} Git для профессионального программиста. -- СПб.: Питер, 2020. -- 496~с. }
	
	\bibitem{sobel:2011}{ \emph{Собель М}. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
