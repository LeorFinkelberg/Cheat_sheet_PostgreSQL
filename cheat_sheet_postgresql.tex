\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Сборник заметок\\по наиболее полезным конструкциям PostgreSQL}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Общие сведения}

\section{Сброс пароля для \texttt{psql} и \texttt{pgAdmin4}}

Для того чтобы доступ к базам данных через терминальный клиент \texttt{psql} или через web-интерфейс \texttt{pgAdmin4} можно было выполнять без ввода пароля, нужно сделать следующее:
\begin{itemize}
	\item найти файл \texttt{pg\_hba.conf}; на ОС Windows он располагается по адресу \directory{C: > Program Files > PostgreSQL > 11 > data},
	
	\item заменить в этом файле метод \texttt{md5} (в нижней части файла) на \texttt{trust}.
\end{itemize}

После исправлений файл \texttt{pg\_hba.conf} должен выглядеть приблизительно так
\begin{lstlisting}[
title = {\sffamily pg\_hba.conf},
style = cmd,
numbers = none
]
...
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
host    all             all             0.0.0.0/0               trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
host    all             all             ::0/0                   trust
# Allow replication connections from localhost, by a user with the
# replication privilege.
host    replication     all             127.0.0.1/32            trust
host    replication     all             ::1/128                 trust
host    appdb           app             all                     trust

\end{lstlisting}


\section{Логический порядок обработки инструкции \texttt{SELECT}}

Порядок обработки инструкции \texttt{SELECT} определяет, когда объекты, определенные в одном шаге, становятся доступными для предложений в последующих шагах. Например, если обработчик запросов можно привязать к таблицам или представлениям, определенным в предложении \texttt{FROM}, эти объекты и их столбцы становятся доступными для всех последующих шагов.

Общая процедура выполнения \texttt{SELECT} следущая (подробности см. в документации~\href{https://postgrespro.ru/docs/postgresql/9.5/sql-select}{\texttt{SELECT}}):

\begin{enumerate}
	\item \texttt{WITH}: выполняются все запросы в списке \texttt{WITH}; по сути они формируют временные таблицы, к которым затем можно обращаться в списке \texttt{FROM}; запрос в \texttt{WITH} выполняется только один раз, даже если он фигурирует в списке \texttt{FROM} неоднократно,
	
	\item \texttt{FROM}: вычисляются все элементы в списке \texttt{FROM} (каждый элемент в списке \texttt{FROM} представляет собой реальную или виртуальную таблицу); другими словами конструируются таблицы из списка \texttt{FROM},
	
	\item \texttt{ON}: выбираются строки, удовлетворяющие заданному условию,
	
	\item \texttt{JOIN}: выполняется объединение таблиц,
	
	\item \texttt{WHERE}: исключаются строки, не удовлетворяющие заданному условию,
	
	\item \texttt{GROUP BY}: вывод разделяется по группам строк, соответствующим одному или нескольким значениям, а затем вычисляются результаты агрегатных функций,
	
	\item \texttt{HAVING}: исключаются группы, не удовлетворяющие заданному условию,
	
	\item \texttt{SELECT},
	
	\item \texttt{DISTINCT}: исключаются \emph{повторяющиеся} строки; \texttt{SELECT DISTINCT ON} исключает строки, совпадающие по всем указанным выражениям; \texttt{SELECT ALL} (по умолчанию) возвращает все строки результата, включая дубликаты,
	
	\item \texttt{UNION}, \texttt{INTERSECT} и \texttt{EXCEPT}: объединяется вывод нескольких команд \texttt{SELECT} в один результирующий набор.
	
	\item \texttt{ORDER BY}: строки сортируются в указанном порядке; в отсутствие \texttt{ORDER BY} строки возвращаются в том порядке, в каком системе будет проще их выдавать,
	
	\item \texttt{LIMIT} (или \texttt{FETCH FIRST}), либо \texttt{OFFSET}: возвращается только подмножество строк результата.
	
	\item Если указано \texttt{FOR UPDATE}, \texttt{FOR NO KEY UPDATE}, \texttt{FOR SHARE} или \texttt{FOR KEY SHARE}, оператор \texttt{SELECT} блокирует выбранные строки, защищая их от одновременных изменений.
\end{enumerate}

\section{Смена схемы базы данных}

Вывести список доступных схем

\begin{lstlisting}[
style = sql,
numbers = none,
]
SHOW search_path;
\end{lstlisting}

Задать схему 

\begin{lstlisting}[
style = sql,
numbers = none
]
SET search_path TO new_schema;
\end{lstlisting}
или, если требуется доступ к нескольким схемам
\begin{lstlisting}[
style = sql,
numbers = none,
]
SET search_path TO new_schema1, new_schema2, public;
\end{lstlisting}

\section{Создание таблицы}

\subsection{Базовые синтаксис создания таблицы}

Для создания таблиц в языке SQL служит команда \texttt{CREATE TABLE}. Упрощенный синтаксис таков
\begin{lstlisting}[
style = sql,
numbers = none
]
CREATE TABLE table_name(
    field_name data_type [constraint],
    field_name data_type [constraint],
    ...
    [constraint],
    [primary key],
    [foreign key]
);
\end{lstlisting}

Пример
\begin{lstlisting}[
style = sql,
numbers = none
]
CREATE TABLE aircrafts(
    aircraft_code CHAR(3) NOT NULL,
    model TEXT NOT NULL,
    range INTEGER NOT NULL,
    CHECK (range > 0),           -- ограничение
    PRIMARY KEY (aircraft_code)  -- первичный ключ
);
\end{lstlisting}

\subsection{Создать таблицу по образу другой таблицы}

Создать таблицу со структурой данных, аналогичной другой таблице (но \emph{без} ограничений базовой таблицы) можно так
\begin{lstlisting}[
style = sql,
numbers = none,
]
CREATE TABLE tbl_name AS
    SELECT * FROM base_tbl LIMIT 0;
\end{lstlisting}  
или более короткий вариант
\begin{lstlisting}[
style = sql,
numbers = none,
]
CREATE TABLE tbl_name(LIKE base_tbl);
\end{lstlisting}

\section{Подзапросы}

По связанности подзапросы делятся на:
\begin{itemize}
	\item \emph{связанные} (или коррелированные) подзапросы, т.е. такие подзапросы, которые ссылаются на элементы внешнего подзапроса или элементы главного запроса,
	
	\item \emph{несвязанные} (или некоррелированные) подзапросы.
\end{itemize}

Фундаментальная концепция состоит в том, что связанные подзапросы выполняются для \emph{каждой} записи (строки) из внешнего подзапроса (или главного запроса), а несвязанные выполняются один раз.

\section{Копирование данных между файлом и таблицей}

Скопировать данные из внешнего файла в таблицу (по сути загрузить данные) можно с помощью команды \texttt{COPY}. С помощью этой же команды можно записать данные из таблицы в файл.

Общий синтаксис команды выглядит так
\begin{lstlisting}[
style = sql,
numbers = none,
]
-- копирует содержимое файла в таблицу
COPY имя_таблицы [ ( имя_столбца [, ...] ) ]
    FROM { 'имя_файла' | PROGRAM 'команда' | STDIN }
    [ [ WITH ] ( параметр [, ...] ) ]

-- копирует содрежимое таблицы в файл
COPY { имя_таблицы [ ( имя_столбца [, ...] ) ] | ( запрос ) }
    TO { 'имя_файла' | PROGRAM 'команда' | STDOUT }
    [ [ WITH ] ( параметр [, ...] ) ]
\end{lstlisting}

Здесь допускается \texttt{параметр}:
\begin{lstlisting}[
style = sql,
numbers = none,
]
FORMAT имя_формата
OIDS [ boolean ]
FREEZE [ boolean ]
DELIMITER 'символ_разделитель'
NULL 'маркер_NULL'
HEADER [ boolean ]
QUOTE 'символ_кавычек'
ESCAPE 'символ_экранирования'
FORCE_QUOTE { ( имя_столбца [, ...] ) | * }
FORCE_NOT_NULL ( имя_столбца [, ...] )
FORCE_NULL ( имя_столбца [, ...] )
ENCODING 'имя_кодировки'
\end{lstlisting}

Примеры
\begin{lstlisting}[
style = sql,
numbers = none,
]
-- сохранить данные из таблицы `family` в файл `family.csv`
postgres=# COPY family TO 'E:/[WorkDirectory]/GARBAGE/family.csv' DELIMITER ',';

-- загрузить в таблицу `family` данные из файла `family.csv`
postgres=# CREATE TABLE family (
               person TEXT PRIMARY KEY,
               parent TEXT REFERENCES family  -- создать внешний ключ на person
           );
postgres=# COPY family FROM 'E:/[WorkDirectory]/GARBAGE/family.csv' DELIMITER ',';
\end{lstlisting}

\section{Обновление записей. Команда \texttt{UPDATE}}

Изменить слово Drama на Dramatic в столбце \texttt{kind} таблицы \texttt{films}

\begin{lstlisting}[
style = sql,
numbers = none,
]
UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';
\end{lstlisting}

Изменить значение температуры и сбросить уровень осадков к значению по умолчанию в одной строке таблицы \texttt{weather}

\begin{lstlisting}[
style = sql,
numbers = none,
deletekeywords = {date}
]
UPDATE
    weather
SET
    temp_lo = temp_lo + 1,
    temp_hi = temp_lo + 15,
    prcp = DEFAULT
WHERE
    city = 'San Francisco' AND
    dates = '2003-07-03';
\end{lstlisting}


\section{Общие табличные выражения}

В конструкциях общих табличных выражений с \texttt{WITH} имена временных таблиц указываются \emph{без} перечисления имен столбцов, а в конструкциях с \texttt{WITH RECURSIVE} -- с перечислением, например, \lstinline[style=sql]{WITH RECURSIVE tab(col1, col2, ...) AS (...)}.

Ссылки на общие табличные выражения в главном запросе можно трактовать как имена таблиц. PostgreSQL выполняет общее табличное выражение \emph{только один раз}, кеширует результаты, а затем повторно использует, вместо того чтобы выполнять подзапросы всякий раз, как они встречаются в главном запросе \cite[\strbook{169}]{juba:2019}.

\subsection{Конструкция \texttt{WITH}}

Основное предназначение \texttt{SELECT} в предложении \texttt{WITH} (Common Table Expression, Общие Табличные Выражения) заключается в разбиении сложных запросов на простые части. Например, пусть задана некоторая таблица \texttt{orders}\footnote{См.~документацию \psql~ \url{https://postgrespro.ru/docs/postgrespro/9.5/queries-with}}

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH --part 1, common table expression
    regional_sales AS ( --def temp_table1
        SELECT region, sum(amount) AS total_sales
        FROM orders --base table
        GROUP BY region
    ),
    top_regions AS ( --def temp_table2
        SELECT region
        FROM regional_sales --temp_table1
        WHERE total_sales > (
                    SELECT SUM(total_sales)/10
                    FROM regional_sales --temp_table2
        )
    )
SELECT --part 2
    region,
    product,
    SUM(quantity) AS product_units,
    SUM(amount) AS product_sales
FROM orders
WHERE region IN (
            SELECT region
            FROM top_regions --temp_table2
)
GROUP BY region, product;
\end{lstlisting}

Здесь в инструкции \texttt{WITH} объявляются две \emph{временные таблицы} \texttt{regional\_sales} и \texttt{top\_regions}. Вторая временная таблица \texttt{top\_regions} ссылается на временную таблицу \texttt{regional\_sales}, сформированную в первых строках настоящего запроса. Во второй части запроса также используется временная таблица \texttt{top\_regions}.

Еще один пример. Пусть задана таблица
\begin{lstlisting}[
style = sql,
numbers = none,
]
# SELECT * FROM test_tab;
 id |    cae_name     |  solver  | num_cores
  1 | ANSYS           | Direct   |        32
  3 | Comsole         | Direct   |        16
  4 | LMS Virtual Lab | Direct   |        32
  2 | Nastran         | Iterativ |        16
(4 строки)
\end{lstlisting}

Требуется выяснить сколько CAE-пакетов имеют прямой, а сколько итерационный решатель. Эту задачу можно решить следующим образом

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH sub_tab AS ( --make temp table
    SELECT solver, 1 AS count
    FROM test_tab
)
SELECT solver, sum(count)
FROM sub_tab --link to temp table
GROUP BY solver;
\end{lstlisting}

Часть с \texttt{WITH} возвращает

\begin{lstlisting}[
style = sql,
numbers = none,
]
# SELECT solver, 1 AS count FROM test_tab;
 solver   | count
=================
 Direct   |     1
 Direct   |     1
 Direct   |     1
 Iterativ |     1
(4 строки)
\end{lstlisting}

Полезный пример с использованием конструкции \lstinline{CASE...END} и \lstinline{WHEN...THEN}

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH cte_film AS ( --part 1
    SELECT
        film_id,
        title,
        (CASE --start block
            WHEN length < 30 THEN 'Short'
            WHEN length < 90 THEN 'Medium'
            ELSE 'Long'
         END) length
    FROM
        film
)
SELECT --part 2
    film_id,
    title,
    length
FROM
    cte_film
WHERE
    length = 'Long'
ORDER BY
    title;
\end{lstlisting}

Пример с использованием логических операторов

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH cte_films AS (
    SELECT
        film_id,
        title,
        (CASE
            WHEN length < 30 THEN 'Short'
            WHEN length >= 30 AND length < 90 THEN 'Medium'
            WHEN length > 90 THEN 'Long'
        END) length
    FROM
        film
)

\end{lstlisting}

\subsection{Конструкция \texttt{WITH RECURSIVE}}

Если к \texttt{WITH} добавить \texttt{RECURSIVE}, то можно будет получить доступ к промежуточному результату. Например,

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE tbl(n) AS ( --part 1
    SELECT 1 --or VALUES(1). This is nonrecursive part
    UNION ALL
    SELECT n+1 FROM tbl WHERE n < 10  --and this is recursive part
)
SELECT sum(n) from tbl; --part 2
\end{lstlisting}

На первой итерации в таблице \texttt{tbl} в атрибуте \texttt{n} находится значение 1. На этом вычисления некурсивной части заканчиваются. Далее переходим к вычислениям в рекурсивной части. Таблица \texttt{tbl} ссылается на последнее вычисленное значение, поэтому на второй итерации удается выполнить \texttt{n+1}, после чего новым значением таблицы \texttt{tbl} станет 2 (\lstinline{tbl -> 2}). Проверяем условие \lstinline{n < 10}, а затем переходим к следующей итерации и т.д.

Удобно представлять, что вычисленные значения хранятся в некоторой промежуточной области в порядке вычисления, а таблица \texttt{tbl} всегда ссылается на последнее вычисленное значение.

На последнем этапе \texttt{1} объединяется с \texttt{2}, \texttt{3} и т.д., т.е. в итоге получается последовательность от 1 до 10. Во второй части запроса остается лишь просуммировать элементы этой последовательности и вывести на экран.

Рассмотрим еще такой пример

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE
    included_parts(sub_part, part, quantity) AS (
        SELECT --nonrecursive part
            sub_part,
            part,
            quantity
        FROM parts --base table
        WHERE part = "our_product"
            UNION ALL
        SELECT --recursive part
            p.sub_part,
            p.part,
            p.quantity
        FROM
            included_parts pr,
            parts p
        WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) AS total_quantity
FROM included_parts
GROUP BY sub_part
\end{lstlisting}

На первой итерации временная таблица \texttt{included\_parts}, вычисленная в некурсивной части, представляет собой результат выборки строк и столбцов из таблицы \texttt{parts}. В рекурсивной части можно получить доступ к этой таблице. В завершении выполняем выборку из таблицы \texttt{included\_parts} по столбцу \texttt{sub\_part}, группируем по нему и выводим сумму по \texttt{quantity}.

Еще один полезный пример. Пусть дана таблица сотрудников

\begin{lstlisting}[
title = {\sffamily employees},
numbers = none]
id | name   | salary | job              | manager_id
====================================================
1  | John   | 10000  | CEO              | null
2  | Ben    | 1400   | Junior Developer | 5
3  | Barry  | 500    | Intern           | 5
4  | George | 1800   | Developer        | 5
5  | James  | 3000   | Manager          | 7
6  | Steven | 2400   | DevOps Engineer  | 7
7  | Alice  | 4200   | VP               | 1
8  | Jerry  | 3500   | Manager          | 1
9  | Adam   | 2000   | Data Analyst     | 8
10 | Grace  | 2500   | Developer        | 8
11 | Leor   | 5000   | Data Scientist   | 6
\end{lstlisting}

Выведем иерархию подчинения сотрудников в компании

\begin{lstlisting}[
style = sql,
numbers = none,
]
WITH RECURSIVE managers(id, name, manager_id, job, level) AS (
    SELECT id, name, manager_id, job, 1
    FROM employees --base table
    WHERE id = 7
        UNION ALL
    SELECT e.id, e.name, e.manager_id, e.job, m.level+1
    FROM employees e JOIN managers m ON e.manager_id = m.id
)
SELECT * FROM managers;
\end{lstlisting}

Сначала в \emph{некурсивной} части \texttt{WITH RECURSIVE} объявляется временная таблица \texttt{managers(id, name, ...)}. Она строится на базе таблицы \texttt{employees}, к которой слева добавляется столбец, состоящий из одних единиц. Затем выбираются строки, удовлетворяющие условию \texttt{WHERE}; в данном случае это одна строка \texttt{e.manager\_id=m.id}.

И, таким образом, на данном этапе во \emph{временную} таблицу \texttt{managers} попадет только одна строка
\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в нерекурсивной части},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
7  | Alice  | 1          | VP               | 1
\end{lstlisting}

Переходим в рекурсивную часть CTE. Из базовой таблицы \texttt{employees} выбираем те строки, которые в столбце \texttt{manager\_id} имеют те же значения, что и в столбце \texttt{id} временной таблицы \texttt{managers} (на данном этапе таблица состоит из одной строки). Другими словами, выбрать нужно те строки, у которых в столбце \texttt{manager\_id} таблицы \texttt{employees} стоит цифра 7.

В результате временная таблица \texttt{managers} на текущем этапе будет иметь вид

\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в рекурсивной части},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
5  | James  | 7          | Manager          | 2
6  | Steven | 7          | DevOps Engineer  | 2
\end{lstlisting}

Временные таблицы \emph{рекурсивных общих табличных выражений} всегда ссылаются на результат последних вычислений, т.е. на данном этапе временная таблица \texttt{managers} ссылается на таблицу, состоящую из двух строк.

Теперь мы снова выбираем из базовой таблицы \texttt{employees} и временной таблицы те строки, у которых в столбцах \texttt{e.manager\_id} и \texttt{m.id} стоят одинаковые числа (в данном случае 5 и 6).

Таким образом

\begin{lstlisting}[
style = sql,
title = {\sffamily managers, вычисленная в рекурсивной части на 2-ой итерации},
numbers = none
]
id | name   | manager_id | job              | level
========================================================
2  | Ben    | 5          | Junior Developer | 3
3  | Barry  | 5          | Intern           | 3
4  | George | 5          | Developer        | 3 
11 | Leor   | 6          | Data Scientist   | 3 
\end{lstlisting}


Наконец все временные подтаблицы <<склеиваются>> и конструкция \lstinline[style = sql]{SELECT * FROM managers} возвращает таблицу \texttt{managers}

\begin{lstlisting}[
style = sql,
numbers = none
]
id | name   | manager_id | job              | level
========================================================
7  | Alice  | 1          | VP               | 1 --step 1
--------------------------------------------------------
5  | James  | 7          | Manager          | 2 --step 2
6  | Steven | 7          | DevOps Engineer  | 2 --step 2
--------------------------------------------------------
2  | Ben    | 5          | Junior Developer | 3 --step 3
3  | Barry  | 5          | Intern           | 3 --step 3
4  | George | 5          | Developer        | 3 --step 3
11 | Leor   | 6          | Data Scientist   | 3 --step 3
\end{lstlisting}





\subsection{Изменение данных в \texttt{WITH}}

В предложении \texttt{WITH} можно также использовать операторы, изменяющие данные (\texttt{INSERT}, \texttt{UPDATE} или \texttt{DELETE}). Это позволяет выполнять в одном запросе сразу несколько разных операций. Например

\begin{lstlisting}[
style = sql,
numbers = none
]
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        dates >= '2010-10-01' AND
        dates < '2010-11-01'
    RETURNING *
)
INSERT INTO products_log (SELECT * FROM moved_rows);
\end{lstlisting}

Этот запрос фактически перемещает строки из таблицы \texttt{products} в таблицу \texttt{products\_log} (таблица должна уже существовать на момент выполнения запроса). Оператор \texttt{DELETE} удаляет указанные строки из \texttt{products} и возвращает их содержимое в предложении \texttt{RETURNING}, а затем главный запрос читает это содержимое и вставляет в таблицу \texttt{products\_log}.

\section{Оконные функции}



\section{Работа со строками и регулярные выражения}

Больше информации про строковые функции и операторы можно найти на страницах официальной документации \texttt{PostgreSQL} по ссылке \url{https://postgrespro.ru/docs/postgrespro/9.6/functions-string}.

Пусть дана таблица \texttt{employees} вида
\begin{lstlisting}[
numbers = none
]
 id |  name  | salary |       job        | manager_id
----+--------+--------+------------------+------------
  1 | John   |  10000 | CEO              |
  2 | Ben    |   1400 | Junior Developer |          5
  3 | Barry  |    500 | Intern           |          5
  4 | George |   1800 | Developer        |          5
  5 | James  |   3000 | Manager          |          7
  6 | Steven |   2400 | DevOps Engineer  |          7
  7 | Alice  |   4200 | VP               |          1
  8 | Jerry  |   3500 | Manager          |          1
  9 | Adam   |   2000 | Data Analyst     |          8
 10 | Grace  |   2500 | Developer        |          8
 11 | Leor   |  50000 | Data Scientist   |          6
\end{lstlisting}

Выбрать те строки из столбца \texttt{job}, в которых содержатся строковые значения, удовлетворяющие шаблону \texttt{'\_ata \%'}, означающий, что первый символ строки может быть любым, а после пробелов может не быть ни одного символа или быть сколько угодно символов. То есть символ <<\texttt{\_}>> совпадает с любым символом, а символ <<\texttt{\%}>> совпадает с произвольным количеством символов. Здесь используется предложение \texttt{LIKE}, которое чувствительно к регистру. В качестве альтернативного варианта можно использовать предложение \texttt{ILIKE}\footnote{Это расширение \texttt{PostgreSQL}, которое не имеет отношения к стандарту \texttt{SQL}}, которое не учитывает регистр.

\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job LIKE '_ata %';
\end{lstlisting}

Выведет
\begin{lstlisting}[
numbers = none
]
 id | name | salary |      job       | manager_id
----+------+--------+----------------+------------
  9 | Adam |   2000 | Data Analyst   |          8
 11 | Leor |  50000 | Data Scientist |          6
\end{lstlisting}

Подобные задачи можно решать и с помощью предложения \texttt{SIMILAR TO}, которое похоже на \texttt{LIKE}, но в отличие от последнего при интерпретации шаблонов использует определение регулярного выражения стандарта \texttt{SQL}. Регулярные выражения \texttt{SQL} -- это смесь нотации предложения \texttt{LIKE} и нотации регулярных выражений.

Шаблоны и \texttt{LIKE}, и \texttt{SIMILAR TO} должны соответствовать \emph{всей} строке целиком, что, вообще говоря, не согласуется с концепцией обычных регулярных выражений, когда шаблон может соответствовать любой части строки. 

\texttt{SIMILAR TO}, как и \texttt{LIKE} использует символ <<\texttt{\_}>> и символ <<\texttt{\%}>>, что соотвествует \texttt{.} и \texttt{.*} в регулярных выражениях \texttt{POSIX}. Дополнительно поддерживаются символы \texttt{|} (указывает альтернативные варианты), \texttt{*} (указывает, что стоящий слева элемент повторяется ноль или более раз), \texttt{+} (указывает, что стоящий слева элемент повторяется один или более раз), \texttt{(...)} (могут использоваться для указания групп), а \texttt{[...]} (определяют символьный класс как в \texttt{POSIX}). Однако \texttt{?} и \texttt{\{...\}} не поддерживаются и кроме того <<\texttt{.}>> не является метасимволом.

Символ <<\verb|\|>> экранирует метасимволы, т.е. <<снимает>> их специальное значение. Другой символ для экранирования можно задать с помощью предложения \texttt{ESCAPE}.

Рассмотренную выше задачу можно решить с помощью \texttt{SIMILAR TO} следующим образом
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job SIMILAR TO '_ata (A|S)%';
\end{lstlisting}

Здесь символ <<\texttt{\%}>>, означающий произвольную последовательность символов, обязателен, так как шаблоны \texttt{SIMILAR TO} должны совпадать со \emph{всей строкой}.

Очень полезна бывает функция \texttt{substring()}. Как и \texttt{SIMILAR TO} шаблон должен совпадать со всей строкой, например
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job FROM employees
WHERE substring(job from '%#"Dev#"%' for '#')='Dev';
\end{lstlisting}

Последовательность символов \texttt{\#"...\#"} задают левую и правую скобки группы (можно указать и какой-то другой символ в качестве скобки, например, \texttt{:"...:"}, но его нужно указать в \texttt{... for ':'}). Последовательность, попавшая между этих символов будет возвращена. Как и раньше символы <<\texttt{\%}>> здесь нужны для того чтобы шаблон совпадал со всей строкой.

Обрезать строку можно так
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job, substring(job,1,4) FROM employees;
\end{lstlisting}

Здесь первое число -- позиция элемента строки (нумерация начинается с единицы), а второе число -- число элементов подстроки, которое нужно оставить в выводе.

Эквивалентная конструкция
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name, job, substring(job from 1 for 4) FROM employees;
\end{lstlisting}

Очень гибкое решение дают \emph{регулярные выражения} \texttt{POSIX} (Portable Operating System Interface -- переносимый интерфейс операционных систем). Например для того чтобы выбрать, как и в рассмотренном выше примере, всех, кто имеет отношение к работе с данными, можно использовать такую конструкцию
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM employees WHERE job ~* 'data .*';
\end{lstlisting}

Здесь \verb|~*| -- оператор соответствию шаблону \emph{без} учета регистра. Если нужно учесть регистр, то используется оператор \verb|~|.

Аналогично \verb|!~| -- оператор несоответствия шаблону с учетом регистра, оператор \verb|!~*| -- оператор несоответствия шаблону \emph{без} учета регистра.

Регулярные выражения могут совпадать с строкой в любом месте (не обязательно со всей строкой).

Еще пример. Нужно выбрать строки из столбца \texttt{job}, в которых последовательность символов \texttt{dev} стоит в начале строки (<<\verb|^|>> -- якорь начала строки)

\begin{lstlisting}[
style = sql,
numbers = none
]
select * from employees where job ~* '^dev.*';
\end{lstlisting}

Пример с положительной проверкой вперед
\begin{lstlisting}[
style = sql,
numbers = none
]
select * from employees where job ~* '(?=engineer)';
\end{lstlisting}

Выведет
\begin{lstlisting}[
numbers = none
]
 id |  name  | salary |       job       | manager_id
----+--------+--------+-----------------+------------
  6 | Steven |   2400 | DevOps Engineer |          7
 20 | Alex   |  25050 | Data Engineer   |         10
\end{lstlisting}

У регулярных выражений есть один тонкий нюанс, связанный с <<жадностью>> квантификатора. Рассмотрим пример
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT substring('xy1234z', 'y*(\d{1,3})');  -- вернет '123'
\end{lstlisting}

Здесь используется <<жадный>> квантификатор \texttt{*}. В общем случае этот квантификатор соответствует элементу, который не повторяется ни разу или повторяется произвольное число раз, однако в данном случае он соответствует строго единственному символу \texttt{'y'} (больше в строке символов \texttt{'y'} нет). Другими словами подшаблон \texttt{y*} жадно забирает символ \texttt{'y'} и на этом успокаивается, так как больше ничего от этой последовательности взять не сможет. А затем подшаблон \verb|\d{1,3}| жадно забирает 3 цифры, так как ему никто не мешает это сделать.

Но если использовать <<нежадный>> вариант квантификатора \texttt{*?}, то картина изменится
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT substring('xy1234z', 'y*?(\d{1,3})');  -- вернет '1'
\end{lstlisting}

Вариант, когда подстрока не имеет ни одного элемента устраивает подшаблон \texttt{y*?} (потому что используется нежадный квантификатор), но не устраивает подшаблон \verb|\d{1,3}|, согласно которому в последовательности должна быть хотя бы одна цифра. Приходится как бы <<тянуть>> подшаблон \texttt{y*?} вправо, потому что нежадный квантификатор стремится схлопнуться в пустое начало строки. Таким образом, на 2-ой итерации курсор сдвигается вправо на один символ и теперь указывате на \texttt{'x'}. Нежадный подшаблон \texttt{y*?} удовлетворен (ему достаточно и пустой подстроки), но не удовлетворен второй подшаблон. Курсор передвигается еще на один элемент вправо. И теперь указывает на \texttt{'y'} (подстрока: \texttt{'xy'}). Нежадный подшаблон \texttt{y*?} снова удовлетворен, но подшаблон \verb|\d{1,3}| все еще не содержит ни одной цифры, поэтому курсор снова перемещается вправо еще на один элемент. В этот раз подстрока выглядит как \texttt{'xy1'}, что удовлетворяет и первый, и второй подшаблоны, но подшаблон \texttt{y*?} больше бы устроил вариант, когда подстрока пустая. С другой стороны подшаблон \verb|\d{1,3}| требует, чтобы в подстроке была хотя бы одна цифра, поэтому подстрока вида \texttt{'xy1'} (в группу попадает только \texttt{1}) -- это компромисс.

\remark{
Удобно представлять, что \emph{нежадные квантификаторы} типа \texttt{*?} представляют собой пружинки сжатия, которые тянут влево и в самом простом случае довольствуются пустой последовательностью, а \emph{жадные квантификаторы} (\texttt{*}) можно представлять как пружинки растяжения, которые стремятся занять всю последовательность и с неохотой уступают элементы
}


\section{Приемы работы в \texttt{pgAdmin 4}}

\section{Приемы работы в \texttt{psql}}

\texttt{psql} -- это терминальный клиент для раоботы с PostgreSQL. Утилита \texttt{psql} предоставляет ряд метакоманд и различные возможности, подобные тем, что имеются у командных оболочек, для облегчения написания скриптов и автоматизации широкого спектра задач.

\subsection{Конфигурационный файл}

Поведением интерактивного терминала \texttt{psql} можно управлять с помощью конфигурационного файла \verb|~/.psqlrc|. На ОС Windows этот файл располагается по адресу \directory{C: > Users > ADM > AppData > Roaming > postgresql} и называется \verb|psqlrc.conf|.

Конфигурационный файл утилиты \texttt{psql} может включать следующие настройки
\begin{lstlisting}[
style = cmd,
title = {\sffamily psqlrc.conf},
numbers = none
]
\set QUIET 1
\timing
\pset border 2
\pset null <NULL>
\set ON_ERROR_STOP on
\setenv PSQL_EDITOR "C:\Program Files\Git\usr\bin\vim.exe"
\set VERBOSITY verbose
\set QUITE 0
\end{lstlisting}

\subsection{Метакоманды \texttt{psql}}

\noindent \verb|\c| или \verb|\connect|: устанавливает новое подключение к серверу PostgreSQL. Параметры подключения можно указывать как позиционно, так и передавая аргумент.

Например
\begin{lstlisting}[
style = sql,
numbers = none
]
=> \c "host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
=> \c postgresql://tom@localhost/mydb?application_name=myapp
\end{lstlisting}

\noindent \verb|\cd|: сменяет текущий рабочий каталог на заданный. Без аргументов устанавливает домашний каталог пользователя.

\noindent \verb|\conninfo|: выводит информацию о текущем подключении к базе данных.

\noindent \verb|\copy|: производит копирование данных с участием клиента. При этом выполнятся SQL-команда \texttt{COPY}, но вместо чтения или записи в файл на сервере, \texttt{psql} читает или записывает файл и пересылает данные между сервером и локальной файловой системой. Это означает, что для доступа к файлам используются привелегии локального пользователя, а не сервера, и не требуются привелегии суперпользователя SQL. Синтаксис команды похож на синтаксис SQL-команды \texttt{COPY}. Все параметры, кроме источника и получателя данных, соответствуют параметрам \texttt{COPY}. Альтернативный способ получить тот же результат, что и с \verb|\copy ... to| -- использовать SQL-команду \texttt{COPY ... TO STDOUT} и завершить ее командой \verb|\g name|.

\noindent \verb|\d[S+]|: для каждого отношения (таблицы, представления, материализованного представления, индекса, последовательности, внешней таблицы) или составного типа, соответствующих шаблону, показывает все столбцы, их типы, табличное пространство и любые специальные атрибуты, такие как \texttt{NOT NULL} или значения по умолчанию. Также показываются связанные индексы, ограничения, правила и триггеры.

\noindent\verb|\da[S]|: выводит список агрегатных функций вместе с типом возвращаемого значения и типами данных, которыми они оперируют.

\noindent\verb|\dD[S+]|: выводит список доменов.

\noindent\verb|\dL[S+]|: выводит список процедурных языков.

\noindent\verb|\dn[S+]|: выводит список схем (пространств имен).

\noindent\verb|\enconding|: устанавливает кодировку набора символов на клиенте. Без аргументов команда показывает текущую кодировку.

\noindent\verb|\!|: выполняет команду операционной системы.



\subsection{Примеры использования}

Вывести список таблиц, присутствующих в базе данных \texttt{postgres}, предварительно задав кодовую страницу, соответствующую Windows-кодировке
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgtes -d postgres -c '\! chcp 1251' -c '\d'
\end{lstlisting}

Вывести первые 5 строк таблицы \texttt{aircrafts} из базы данных \texttt{demo}, организовав вывод строк в вертикальном формате (\verb|\x|; эквивалентно ключу \texttt{ psql} \verb|-x|)
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgtes -d demo -c '\x' -c 'TABLE aircrafts LIMIT 5;'
\end{lstlisting}

\remark{%
Лучше для нескольких команд использовать несколько ключей \texttt{-c}
}

Прочить команды из файла \texttt{sql\_query.sql}, а не из стандартного ввода. По большому счету ключ \texttt{-f} равнозначен метакоманде \verb|\i|
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgtes -f sql_query.sql
\end{lstlisting}

Вывести первые 3 строки таблицы в HTML-формате (\texttt{-H})
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgres -d postgres -H -c '\! chcp 1251' -c 'table family limit 3;'
\end{lstlisting}

Записать вывод результатов всех запросов в файл с именем \texttt{psql\_output.txt}
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgres -d postgres -H -c '\! chcp 1251' -c 'table family limit 3;' \
    -o psql_output.txt
\end{lstlisting}

Вывести таблицу в формате \LaTeX\ и вывод запроса записать в файл \texttt{for\_latex\_output.txt}
\begin{lstlisting}[
style = sql,
numbers = none
]
$ psql -U postgres -d postgres -P format=latex \
    -c '\! chcp 1251' -c 'table family limit 3;' \
    -o for_latex_output.txt
\end{lstlisting}

\section{Специальные функции и операторы}

\subsection{Предикаты \texttt{ANY}, \texttt{ALL}}

Использование \texttt{IN} эквивалентно \texttt{= ANY}, а использование \texttt{NOT IN} эквивалентно \texttt{<> ALL}. Пример
\begin{lstlisting}[
style = sql,
numbers = none
]
-- есть ли совпадение хотя бы с одним элементом массива?
SELECT 'test'::text = ANY('{"test","non-test"}'::text[]); -- true
-- есть ли совпадение со всеми элементами массива?
SELECT 'test'::text = ALL('{"test","non-test"}'::text[]); -- false
\end{lstlisting}

\subsection{Оператор конкатенации}

Соединить два массива можно с помощью оператора \texttt{||} 
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT '{2,3,10}'::int[] || '{5}'::int[]; -- {2,3,10,5}
\end{lstlisting}

С помощью этого же оператора можно <<склеивать>> строки
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT name || '[ ' || job ' ]' AS record FROM employees; -- Ben[ Junior Developer ]
\end{lstlisting}

К слову, у PostgreSQL нестрогая типизация. То есть PostgreSQL проводит неявное преобразование типов, например, когда используется оператор конкатенации, склеивающий строку и число, то выполняется неявное преобразование числового типа в строковый.

\subsection{Диапазонные операторы}

Подробнее вопрос обсуждается в документации PostgreSQL \href{https://postgrespro.ru/docs/postgrespro/10/functions-range}{9.19. Диапазонные функции и операторы}.

С помощью оператора \verb|@>| удобно проверять покрывает ли диапазон слева от оператора диапазон справа от оператора
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT '{2,3,5}'::int[] @> '{3}'::int[]  -- true
\end{lstlisting}

Можно проверить содержит ли диапазон слева от оператора элемент справа от оператора
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT '[2011-01-01,2011-03-01)'::tsrange @> '2011-01-10'::timestamp;  --true
\end{lstlisting}

Если требуется выяснить содержится ли элемент в диапазоне, то используется оператор \verb|<@|
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT 42 <@ int4range(2,10); --false
-- принадлежит ли 3 полуотрезку [2,10)
SELECT 3 || ' in ' || int4range(2,10) AS cond, 3 <@ int4range(2,10) AS bool;  --true
\end{lstlisting}

Общие элементы (пересечение) удобно выявлять с помощью оператора \verb|&&|
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT '{3}'::int[] && '{2,3,5}'::int[]; --true
\end{lstlisting}

\subsection{Функции, генерирующие ряды значений}

Очень полезна бывает функция \texttt{generate\_series(start, stop, step)}, которая возвращает последовательность в общем случае вещественных чисел от \emph{start} до \emph{stop} с заданным шагом \emph{step}
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT generate_series(1.1, 4, 1.3) AS real_num;
\end{lstlisting}
выведет
\begin{lstlisting}[
style = cmd,
numbers = none
]
+----------+
| real_num |
+----------+
|      1.1 |
|      2.4 |
|      3.7 |
+----------+
(3 строки)
\end{lstlisting}

Сгенерировать несколько временных меток с шагом в 5 часов
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT generate_series('2020-05-01 00:00'::timestamp,
                       '2020-05-01 22:00'::timestamp,
                       '5 hours'::interval) AS dates;
\end{lstlisting}
выведет
\begin{lstlisting}[
style = cmd,
numbers = none
]
+---------------------+
|        dates        |
+---------------------+
| 2020-05-01 00:00:00 |
| 2020-05-01 05:00:00 |
| 2020-05-01 10:00:00 |
| 2020-05-01 15:00:00 |
| 2020-05-01 20:00:00 |
+---------------------+
(5 строк)
\end{lstlisting}

Когда после функции в предложении \texttt{FROM} добавляется \texttt{WITH ORDINALITY}, в выходные данные добавляется столбец типа \texttt{bigint}, числа в котором начинаются с 1 и увеличиваются на 1 для каждой строки, выданной функцией. Пример
\begin{lstlisting}[
style = sql,
numbers = none
]
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls, n) LIMIT 5;
\end{lstlisting}
выведет
\begin{lstlisting}[
style = cmd,
numbers = none
]
+------------------+---+
|        ls        | n |
+------------------+---+
| base             | 1 |
| current_logfiles | 2 |
| global           | 3 |
| log              | 4 |
| pg_commit_ts     | 5 |
+------------------+---+
\end{lstlisting}




% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{juba:2019}{ \emph{Джуба С.}, \emph{Волков А.} Изучаем PostgreSQL 10. -- М.: ДМК Пресс, 2019. -- 400 с.}
	
	\bibitem{chacon:2020}{ \emph{Чакон С.}, \emph{Штрауб Б.} Git для профессионального программиста. -- СПб.: Питер, 2020. -- 496~с. }
	
	\bibitem{sobel:2011}{ \emph{Собель М}. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
